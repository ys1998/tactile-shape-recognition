#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.14
# In conjunction with Tcl version 8.6
#    Jul 03, 2018 03:20:44 PM

# Configure paths
import sys
sys.path.append('libraries/iLimb')
sys.path.append('libraries/UR10')
sys.path.append('libraries/neuromorphic')
sys.path.append('libraries/general')
sys.path.append('libraries/controlsyst')
sys.path.append('../scripts')

import os, subprocess, time
import numpy as np
from copy import copy
from iLimb import *
from tactileboard import *
from UR10 import *
from threadhandler import ThreadHandler
from pcd_io import save_point_cloud
from ur10_simulation import ur10_simulator
from iLimb_trajectory import get_coords
import shape_recog_gui_support

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

# Plotting libraries
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt

MAPPING = {'index':2, 'thumb':4}
THRESHOLD = {'index':0.01, 'thumb':0.01}

""" Abstract class for storing state variables """
class STATE:
	ROTATION_ANGLE = 30
	ROTATION_POS = 0 # 0,1,2,3
	ROTATION_DIR = -1 # -1/1
	
	NUM_POINTS = 0
	CONTACT_POINTS = []
	CONTROL_POS = [0 for _ in range(5)]
	FINGER_POS = {'index':[], 'thumb':[]}
	XYZR = []
	UNIT_VECTOR = []

	STOP = False

# iLimb dimensions (mm)
IDX_TO_BASE = 185 + 40
THB_TO_BASE = 105 + 30
IDX_0 = 50
IDX_1 = 30
THB = 65

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = Tk()
    top = Shape_Recognition (root)
    shape_recog_gui_support.init(root, top)
    root.mainloop()

w = None
def create_Shape_Recognition(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = Toplevel (root)
    top = Shape_Recognition (w)
    shape_recog_gui_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_Shape_Recognition():
    global w
    w.destroy()
    w = None


class Shape_Recognition:
        def __init__(self, top=None):
                '''This class configures and populates the toplevel window.
                        top is the toplevel containing window.'''
                _bgcolor = '#ffffff'  # X11 color: 'gray85'
                _fgcolor = '#000000'  # X11 color: 'black'
                _compcolor = '#ffffff' # X11 color: 'gray85'
                _ana1color = '#ffffff' # X11 color: 'gray85' 
                _ana2color = '#ffffff' # X11 color: 'gray85' 

                top.geometry("794x691+459+134")
                top.title("3D Shape Recognition")
                top.configure(highlightcolor="black")

                # Handlers
                self.ur10 = None
                self.sensors = None
                self.iLimb = None

                # Figures 
                self.pov_figures = [Figure() for _ in range(6)]
                self.view_0 = Canvas(top)
                self.view_0.place(relx=0.01, rely=0.01, relheight=0.26, relwidth=0.23)
                self.view_0.configure(borderwidth="2")
                self.view_0.configure(relief=RIDGE)
                self.view_0.configure(selectbackground="#c4c4c4")
                self.view_0.configure(width=171)

                self.view_1 = Canvas(top)
                self.view_1.place(relx=0.25, rely=0.01, relheight=0.26, relwidth=0.23)
                self.view_1.configure(borderwidth="2")
                self.view_1.configure(relief=RIDGE)
                self.view_1.configure(selectbackground="#c4c4c4")
                self.view_1.configure(width=125)

                self.view_2 = Canvas(top)
                self.view_2.place(relx=0.49, rely=0.01, relheight=0.26, relwidth=0.23)
                self.view_2.configure(borderwidth="2")
                self.view_2.configure(relief=RIDGE)
                self.view_2.configure(selectbackground="#c4c4c4")
                self.view_2.configure(width=125)

                self.view_3 = Canvas(top)
                self.view_3.place(relx=0.01, rely=0.29, relheight=0.26, relwidth=0.23)
                self.view_3.configure(borderwidth="2")
                self.view_3.configure(relief=RIDGE)
                self.view_3.configure(selectbackground="#c4c4c4")
                self.view_3.configure(width=171)

                self.view_4 = Canvas(top)
                self.view_4.place(relx=0.25, rely=0.29, relheight=0.26, relwidth=0.23)
                self.view_4.configure(borderwidth="2")
                self.view_4.configure(relief=RIDGE)
                self.view_4.configure(selectbackground="#c4c4c4")
                self.view_4.configure(width=171)

                self.view_5 = Canvas(top)
                self.view_5.place(relx=0.49, rely=0.29, relheight=0.26, relwidth=0.23)
                self.view_5.configure(borderwidth="2")
                self.view_5.configure(relief=RIDGE)
                self.view_5.configure(selectbackground="#c4c4c4")
                self.view_5.configure(width=171)

                self.Labelframe1 = LabelFrame(top)
                self.Labelframe1.place(relx=0.73, rely=0.01, relheight=0.17
                        , relwidth=0.25)
                self.Labelframe1.configure(relief=GROOVE)
                self.Labelframe1.configure(text='''General''')
                self.Labelframe1.configure(width=200)

                self.initialize = Button(self.Labelframe1, command=self.init_handlers)
                self.initialize.place(relx=0.05, rely=0.19, height=26, width=174, y=-11
                        , h=5)
                self.initialize.configure(activebackground="#d9d9d9")
                self.initialize.configure(text='''Initialize''')

                self.configure = Button(self.Labelframe1, command=self.configure_handlers)
                self.configure.place(relx=0.05, rely=0.48, height=26, width=174, y=-11
                        , h=5)
                self.configure.configure(activebackground="#d9d9d9")
                self.configure.configure(text='''Configure''')

                self.start_main = Button(self.Labelframe1, command=self.init_main)
                self.start_main.place(relx=0.05, rely=0.77, height=26, width=87, y=-11
                        , h=5)
                self.start_main.configure(activebackground="#d9d9d9")
                self.start_main.configure(text='''Start''')

                self.stop_main = Button(self.Labelframe1, command=self.break_main)
                self.stop_main.place(relx=0.5, rely=0.77, height=26, width=87, y=-11
                        , h=5)
                self.stop_main.configure(activebackground="#d9d9d9")
                self.stop_main.configure(text='''Stop''')

                self.Labelframe2 = LabelFrame(top)
                self.Labelframe2.place(relx=0.73, rely=0.19, relheight=0.21
                        , relwidth=0.25)
                self.Labelframe2.configure(relief=GROOVE)
                self.Labelframe2.configure(text='''UR10''')
                self.Labelframe2.configure(width=200)

                self.to_home = Button(self.Labelframe2, command=self.move_to_home)
                self.to_home.place(relx=0.05, rely=0.15, height=26, width=174, y=-11
                        , h=5)
                self.to_home.configure(activebackground="#d9d9d9")
                self.to_home.configure(text='''Move to "Home"''')

                self.to_base = Button(self.Labelframe2, command=lambda: self.move_to_base(t=5))
                self.to_base.place(relx=0.05, rely=0.37, height=26, width=174, y=-11
                        , h=5)
                self.to_base.configure(activebackground="#d9d9d9")
                self.to_base.configure(text='''Move to base''')

                self.move_up = Button(self.Labelframe2, command=lambda: self.move_vertical(_dir=1))
                self.move_up.place(relx=0.05, rely=0.6, height=26, width=87, y=-11, h=5)
                self.move_up.configure(activebackground="#d9d9d9")
                self.move_up.configure(text='''Up''')

                self.move_down = Button(self.Labelframe2, command=lambda: self.move_vertical(_dir=-1))
                self.move_down.place(relx=0.5, rely=0.6, height=26, width=87, y=-11, h=5)
                self.move_down.configure(activebackground="#d9d9d9")
                self.move_down.configure(text='''Down''')

                self.rotateHandCW = Button(self.Labelframe2, command=self.rotate_hand_CW)
                self.rotateHandCW.place(relx=0.05, rely=0.82, height=26, width=87, y=-11
                        , h=5)
                self.rotateHandCW.configure(activebackground="#d9d9d9")
                self.rotateHandCW.configure(text='''CW''')
                self.rotateHandCW.configure(width=91)

                self.rotateHandCCW = Button(self.Labelframe2, command=self.rotate_hand_CCW)
                self.rotateHandCCW.place(relx=0.5, rely=0.82, height=26, width=87, y=-11
                        , h=5)
                self.rotateHandCCW.configure(activebackground="#d9d9d9")
                self.rotateHandCCW.configure(text='''CCW''')

                self.Labelframe3 = LabelFrame(top)
                self.Labelframe3.place(relx=0.73, rely=0.41, relheight=0.17
                        , relwidth=0.25)
                self.Labelframe3.configure(relief=GROOVE)
                self.Labelframe3.configure(text='''iLimb''')
                self.Labelframe3.configure(width=200)

                self.to_rest = Button(self.Labelframe3, command=self.move_iLimb_to_rest)
                self.to_rest.place(relx=0.05, rely=0.19, height=26, width=174, y=-11
                        , h=5)
                self.to_rest.configure(activebackground="#d9d9d9")
                self.to_rest.configure(text='''Rest pose''')

                self.closeHand = Button(self.Labelframe3, command=self.close_hand)
                self.closeHand.place(relx=0.05, rely=0.48, height=26, width=174, y=-11
                        , h=5)
                self.closeHand.configure(activebackground="#d9d9d9")
                self.closeHand.configure(text='''Feedback pinch touch''')

                self.openHand = Button(self.Labelframe3, command=self.move_away)
                self.openHand.place(relx=0.05, rely=0.77, height=26, width=174, y=-11
                        , h=5)
                self.openHand.configure(activebackground="#d9d9d9")
                self.openHand.configure(text='''Open hand''')

                self.Labelframe4 = LabelFrame(top)
                self.Labelframe4.place(relx=0.73, rely=0.58, relheight=0.12
                        , relwidth=0.25)
                self.Labelframe4.configure(relief=GROOVE)
                self.Labelframe4.configure(text='''Tactile Sensors''')
                self.Labelframe4.configure(width=200)

                self.calibrate = Button(self.Labelframe4, command=self.calibrate_sensors)
                self.calibrate.place(relx=0.05, rely=0.68, height=26, width=174, y=-11
                        , h=5)
                self.calibrate.configure(activebackground="#d9d9d9")
                self.calibrate.configure(text='''Calibrate''')

                self.start_sensor = Button(self.Labelframe4, command=self.start_sensors)
                self.start_sensor.place(relx=0.05, rely=0.27, height=26, width=87, y=-11
                        , h=5)
                self.start_sensor.configure(activebackground="#d9d9d9")
                self.start_sensor.configure(text='''Start''')

                self.stop_sensor = Button(self.Labelframe4, command=self.stop_sensors)
                self.stop_sensor.place(relx=0.5, rely=0.27, height=26, width=87, y=-11
                        , h=5)
                self.stop_sensor.configure(activebackground="#d9d9d9")
                self.stop_sensor.configure(text='''Stop''')

                self.tactile_thumb = Canvas(top)
                self.tactile_thumb.place(relx=0.01, rely=0.56, relheight=0.2
                        , relwidth=0.71)
                self.tactile_thumb.configure(borderwidth="2")
                self.tactile_thumb.configure(relief=RIDGE)
                self.tactile_thumb.configure(selectbackground="#c4c4c4")
                self.tactile_thumb.configure(width=561)

                self.tactile_index = Canvas(top)
                self.tactile_index.place(relx=0.01, rely=0.78, relheight=0.2
                        , relwidth=0.71)
                self.tactile_index.configure(borderwidth="2")
                self.tactile_index.configure(relief=RIDGE)
                self.tactile_index.configure(selectbackground="#c4c4c4")
                self.tactile_index.configure(width=561)

                self.status = LabelFrame(top)
                self.status.place(relx=0.73, rely=0.87, relheight=0.11, relwidth=0.25)
                self.status.configure(relief=GROOVE)
                self.status.configure(text='''Status''')
                self.status.configure(width=200)

                self.statusText = Label(self.status)
                self.statusText.place(relx=0.0, rely=0.1, relwidth=1, relheight=0.8)
                self.statusText.configure(activebackground="#f9f9f9")
                self.statusText.configure(justify=LEFT)
                self.statusText.configure(text='''Nothing to do.''')

                self.visualize = Button(top)
                self.visualize.place(relx=0.73, rely=0.71, height=26, width=201)
                self.visualize.configure(activebackground="#d9d9d9")
                self.visualize.configure(state=ACTIVE)
                self.visualize.configure(text='''Visualize point cloud''')

                self.visualize_surface = Button(top)
                self.visualize_surface.place(relx=0.73, rely=0.75, height=26, width=201)
                self.visualize_surface.configure(activebackground="#d9d9d9")
                self.visualize_surface.configure(text='''Compute convex hull''')

                self.detect_shape = Button(top)
                self.detect_shape.place(relx=0.73, rely=0.79, height=26, width=201)
                self.detect_shape.configure(activebackground="#d9d9d9")
                self.detect_shape.configure(text='''Detect shape''')

                self.reset_values = Button(top, command=self.reset_stored_values)
                self.reset_values.place(relx=0.73, rely=0.83, height=26, width=201)
                self.reset_values.configure(activebackground="#d9d9d9")
                self.reset_values.configure(text='''Clear values''')

        """ Function to clear all collected values """
        def reset_stored_values(self):
                STATE.NUM_POINTS = 0
                STATE.CONTACT_POINTS = []
                STATE.CONTROL_POS = [0 for _ in range(5)]
                STATE.FINGER_POS = {'index':[], 'thumb':[]}
                STATE.XYZR = []
                STATE.UNIT_VECTOR = []

        """ Function to initialize handler objects """
        def init_handlers(self):
                # Create handlers
                print('Initializing handlers ...')
                self.ur10 = UR10Controller('10.1.1.6')
                print('UR10 done.')
                self.iLimb = iLimbController('/dev/ttyACM0')
                self.iLimb.connect()
                print('iLimb done.')
                self.sensors = TactileBoard('/dev/ttyACM1', _sensitivity=TBCONSTS.DEFAULT_SENS)
                # sensors.start()
                # Sleep
                time.sleep(3)
                print('TactileBoard done')

        """ Functions to set all handlers to default configuration """
        def move_to_home(self):
                print('Setting UR10 to default position ...')
                UR10pose = URPoseManager()
                UR10pose.load('shape_recog_home.urpose')
                UR10pose.moveUR(self.ur10,'home_j',5)
                
        def move_iLimb_to_rest(self):
                print('Setting iLimb to default pose ...')
                self.iLimb.setPose('rest')
                time.sleep(3)	
                
        def start_sensors(self):
                self.sensors.start()

        def stop_sensors(self):
                self.sensors.stop()

        def calibrate_sensors(self):
                print('Calibrating tactile sensors ...')
                self.start_sensors()
                self.sensors.startCalibration(500)
                time.sleep(2)
                self.sensors.stopCalibration()
                self.sensors.useCalib = True
                self.sensors.loadCalibration()
                time.sleep(1)

        def configure_handlers(self):
                self.move_to_home()
                self.move_iLimb_to_rest()
                self.calibrate_sensors()
                print('Done.')

        """ Function to close fingers until all fingers touch surface """
        def close_hand(self, fingers=['index', 'thumb']):
                touched = [False] * len(fingers)
                touched_once = False
                fingerArray = [[x, MAPPING[x], THRESHOLD[x]] for x in fingers]
                while not all(touched):
                        time.sleep(0.005)
                        q = self.sensors.getData()
                        for _ in range(len(q)):
                                tactileSample = q.popleft()
                                touched = self.iLimb.doFeedbackPinchTouch(tactileSample, fingerArray, 1)
                                # update control_pos for fingers that have touched a surface
                                for i in range(len(fingerArray)):
                                        if touched[i]:
                                                touched_once = True
                                                STATE.CONTROL_POS[fingerArray[i][1]] = self.iLimb.controlPos
                                                #----------------------------------------------------------
                                                # Collect information
                                                STATE.FINGER_POS[fingerArray[i][0]].append(self.iLimb.controlPos)
                                                #----------------------------------------------------------

                                # Self-touching condition
                                # Can be modified later
                                if self.iLimb.controlPos > 500 and not touched_once:
                                        return False
                                elif self.iLimb.controlPos > 500 and touched_once:
                                        for i in range(len(fingerArray)):
                                                if not touched[i]:
                                                        #----------------------------------------------------------
                                                        # Collect information
                                                        STATE.FINGER_POS[fingerArray[i][0]].append(-1)
                                                        #----------------------------------------------------------
                                        return True

                                if all(touched):
                                        return True
                                else:
                                        # update fingerArray
                                        fingerArray = [fingerArray[i] for i in range(len(touched)) if not touched[i]]

        """ Function to calculate coordinates of points of contact """
        def compute_coordinates(self):
                self.ur10.read_joints_and_xyzR()
                xyzR = copy(self.ur10.xyzR)
                joints = copy(self.ur10.joints)
                sim = ur10_simulator()
                sim.set_joints(joints)
                _ = sim.joints2pose()
                _, rm = sim.get_Translation_and_Rotation_Matrix()
                # Calculate the direction in which the end effector is pointing
                # aVlue corresponding to z-direction is ignored
                direction = rm[:2,2] # x and y direction vector only
                direction /= np.linalg.norm(direction)
                
                # Calculate unit vector direction
                dir_ang = np.arctan(abs(direction[1]/direction[0]))
                if direction[0] < 0:
                        if direction[1] < 0:
                                dir_ang += np.pi
                        else:
                                dir_ang = np.pi - dir_ang
                else:
                        if direction[1] < 0:
                                dir_ang = 2*np.pi - dir_ang

                # Find point of contact for index finger
                idx_control = STATE.CONTROL_POS[MAPPING['index']]
                if idx_control > 0:
                        theta = 30 + 60/500 * idx_control
                        if idx_control < 210:
                                # Normal circular motion
                                rel_theta = 30
                        else:
                                rel_theta = 30 + 60/290 * (idx_control - 210)
                        # rel_theta = 30 + 60/500 * idx_control
                        axis = IDX_0 * np.cos(np.deg2rad(theta)) + IDX_1 * np.cos(np.deg2rad(theta+rel_theta))
                        perp = IDX_0 * np.sin(np.deg2rad(theta)) + IDX_1 * np.sin(np.deg2rad(theta+rel_theta))
                        axis += IDX_TO_BASE
                                
                        pt_1 = [axis * np.cos(dir_ang) - perp * np.sin(dir_ang) + xyzR[0],
                                        axis * np.sin(dir_ang) + perp * np.cos(dir_ang) + xyzR[1],
                                        xyzR[2]]
                        STATE.NUM_POINTS += 1
                        STATE.CONTACT_POINTS.append(pt_1)

                # Find point of contact for thumb
                thb_control = STATE.CONTROL_POS[MAPPING['thumb']]
                if thb_control > 0:
                        theta = 90 * (1 - thb_control/500)
                        axis = THB * np.cos(np.deg2rad(theta)) + THB_TO_BASE
                        perp = THB * np.sin(np.deg2rad(theta))

                        pt_2 = [axis * np.cos(dir_ang) - perp * np.sin(dir_ang) + xyzR[0],
                                        axis * np.sin(dir_ang) + perp * np.cos(dir_ang) + xyzR[1],
                                        xyzR[2]]

                        STATE.NUM_POINTS += 1
                        STATE.CONTACT_POINTS.append(pt_2)

                #--------------------------------------------------
                # Collect information
                STATE.XYZR.append(xyzR)
                STATE.UNIT_VECTOR.append(direction)
                #--------------------------------------------------

        """ Functions to rotate hand for next reading """
        def rotate_hand_CW(self):
                self.ur10.read_joints()
                joints = copy(self.ur10.joints)

                if STATE.ROTATION_POS > 0 :
                        STATE.ROTATION_POS -= 1
                        joints[4] += STATE.ROTATION_ANGLE * -1
                        xyzR = self.ur10.move_joints_with_grasp_constraints(joints, dist_pivot=220, grasp_pivot=60, constant_axis='z')
                        self.ur10.movej(xyzR, 3)
                        time.sleep(3.2)
                
        def rotate_hand_CCW(self):
                self.ur10.read_joints()
                joints = copy(self.ur10.joints)

                if STATE.ROTATION_POS < 180//STATE.ROTATION_ANGLE - 1:
                        STATE.ROTATION_POS += 1
                        joints[4] += STATE.ROTATION_ANGLE * 1
                        xyzR = self.ur10.move_joints_with_grasp_constraints(joints, dist_pivot=220, grasp_pivot=60, constant_axis='z')
                        self.ur10.movej(xyzR, 3)
                        time.sleep(3.2)

        def rotate_hand(self):
                # Boundary checks
                if STATE.ROTATION_POS == 0 and STATE.ROTATION_DIR == -1:
                        STATE.ROTATION_DIR = 1
                if STATE.ROTATION_POS == 180//STATE.ROTATION_ANGLE - 1 and STATE.ROTATION_DIR == 1:
                        STATE.ROTATION_DIR = -1
                # Rotate the hand according to direction
                if STATE.ROTATION_DIR == 1:
                        self.rotate_hand_CCW()
                else:
                        self.rotate_hand_CW()

        """ Function to move hand in vertical direction """
        def move_vertical(self, _dir=1):
                # move one step up while palpating
                self.ur10.read_joints_and_xyzR()
                x, y, z, rx, ry, rz = copy(self.ur10.xyzR)
                new_joint_pos = np.array([x, y, z+10*_dir, rx, ry, rz])
                self.ur10.movej(new_joint_pos, 0.5)
                time.sleep(0.7)

        """ Function to move hand away from the object """
        def move_away(self, fingers=['thumb', 'index']):
                self.iLimb.control(fingers, ['position']*len(fingers), [0]*len(fingers))
                time.sleep(1)

        """ Function to move UR10 to base """
        def move_to_base(self, t=1):
                self.ur10.read_joints_and_xyzR()
                x, y, z, rx, ry, rz = copy(self, ur10.xyzR)
                new_joint_pos = np.array([x, y, -200, rx, ry, rz])
                self.ur10.movej(new_joint_pos, t)
                time.sleep(t+.2)

        """ Function to break out of main loop """
        def break_main(self):
                STATE.STOP = True

        """ Main function """
        def init_main(self):
                self.iLimb.setPose('openHand')
                time.sleep(3)
                self.iLimb.control(['thumbRotator'],['position'],[700])
                time.sleep(3)
                
                self.move_to_base(t=5)
                height = 0
                estimated_height = 200

                for _ in range(180//STATE.ROTATION_ANGLE):
                        while height < estimated_height:
                                # Break condition
                                if STATE.STOP:
                                        STATE.STOP = False
                                        return

                                touched = self.close_hand(['thumb', 'index'])
                                time.sleep(0.1)
                                if touched:
                                        self.compute_coordinates()
                                else:
                                        estimated_height = height
                                self.iLimb.resetControl()
                                time.sleep(0.5)
                                self.move_away()
                                self.move_vertical()
                                height += 10
                        self.move_to_base()
                        height = 0
                        estimated_height = 200
                        self.rotate_hand()

                # Convert collected points to a PCD file
                pts = np.asarray(STATE.CONTACT_POINTS)
                # finger_pos = np.asarray([STATE.FINGER_POS['index'], STATE.FINGER_POS['thumb']])
                # np.savetxt('controlpos.txt', finger_pos)
                # np.savetxt('xyzr.txt', np.asarray(STATE.XYZR))
                # np.savetxt('uv.txt', np.asarray(STATE.UNIT_VECTOR))
                save_point_cloud(pts, 'run.pcd')
                subprocess.check_call(['python', 'detect.py', 'save/', 'run.pcd'])

        """ Function to update the 6 PoV images """
        def update_pov(self):
                idx = STATE.FINGER_POS['index']
                thb = STATE.FINGER_POS['thumb']
                xyzr = STATE.XYZR
                uv = STATE.UNIT_VECTOR
                # Get lists of coordinates
                x1, y1, z1, x2, y2, z2 = get_coords(idx, thb, xyzr, uv)
                mu_x = np.mean(np.concatenate([x1,x2]))
                mu_y = np.mean(np.concatenate([y1,y2]))
                mu_z = np.mean(np.concatenate([z1,z2]))

                bx_l = -10 + np.min(np.concatenate([x1,x2]) - mu_x)
                bx_r = 10 + np.max(np.concatenate([x1,x2]) - mu_x)
                by_l = -10 + np.min(np.concatenate([x1,x2]) - mu_x)
                by_r = 10 + np.max(np.concatenate([x1,x2]) - mu_x)
                bz_l = -10 + np.min(np.concatenate([x1,x2]) - mu_x)
                bz_r = 10 + np.max(np.concatenate([x1,x2]) - mu_x)

                view_0_x1 = x1 - mu_x
                view_0_x2 = x2 - mu_x
                view_0_y1 = y1 - mu_y
                view_0_y2 = y2 - mu_y
                fig0 = plt.figure()
                axes = fig.add_subplot(111)
                axes.plot(x,y)

        """ Function to update the tactile sensor readings """
        # def update_sensor_readings(self):


if __name__ == '__main__':
    vp_start_gui()



